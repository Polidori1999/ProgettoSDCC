âœ… Completato finora

Implementazione messaggi MsgLookup e MsgLookupResponse (proto)

Reactive client lookup con TTL e fanout

Forwarding rumor con decremento TTL

Risposta diretta su conn.WriteToUDP al sender

Failure detector con rimozione servizi

    Test: Failover provider node2

ğŸ§© TODO â€“ Feature/Code
ğŸ”„ 1. Rumor deduplication (minimo necessario se TTL > 1)

Memorizzare gli ID dei rumor giÃ  visti (seenLookup map[string]bool)

    Evitare di inoltrare piÃ¹ volte la stessa richiesta

ğŸ”¢ 2. TTL troppo basso

Se TTL = 0 â†’ il nodo non inoltra nulla

    Se TTL = 1 â†’ un solo hop

ğŸ›¤ï¸ 3. Multi-hop relay (A â†’ B â†’ C)

Introdurre node3 nella mesh

Configurare una topologia A â†” B â†” C, dove solo C ha il servizio

    Fare in modo che A scopra â€œordersâ€ passando per B (con TTL â‰¥ 2)

â• 4. Join dinamico (provider che si aggiunge dopo)

Avvia node1 e node2 senza â€œordersâ€

Avvia node3 con --services=orders dopo qualche secondo

    Confermare che il servizio diventa disponibile per lookup

ğŸŒ 5. Partition e recovery

Simulare disconnessione temporanea di node2

Verificare che venga marcato DEAD e i suoi servizi scompaiano

    Riconnessione â†’ ritorno heartbeat e servizi nel registry

ğŸ” TODO â€“ Test (da eseguire uno alla volta)
Test	Obiettivo	Fatto
âœ… Failover provider	Verifica risposta NOT found se provider giÃ¹	âœ…
TTL = 0 / TTL = 1	Controlla che la richiesta non arrivi troppo lontano	â˜
Multi-hop forwarding	A â†’ B â†’ C, TTL=2	â˜
Join dinamico di provider	node3 si unisce offrendo il servizio	â˜
Partition e riconnessione	node2 si isola, poi torna	â˜

Fammi sapere da quale vuoi partire ora: TTL, forwarding a 3 nodi o join dinamico?





























15/07
vedere se effettivamente Ã¨ giusto k fault tollerance
vedere timer dinamico
differenziare leave volontario da crash, magari tramite id
fixare qualche log
service discovery   facendo rumor spreading
