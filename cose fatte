ğŸ§± Componenti principali
1. Node

ğŸ“„ File: node.go

ğŸ§  ResponsabilitÃ :

    Classe principale che incapsula tutta la logica.

    Inizializza e collega tutte le componenti (PeerManager, ServiceRegistry, ecc.).

    Avvia il listener UDP, gestisce i messaggi in arrivo e il lookup.

ğŸ”§ Contiene:

    ID, Port = identificatore del nodo.

    PeerMgr = gestore peer conosciuti.

    Registry = registro dei servizi.

    Digests, GossipM, FailureD = componenti operative.

ğŸ§ª Metodo Run(lookup)

    Se lookup Ã¨ attivo: aspetta heartbeat, poi fa lookup del servizio.

    Altrimenti rimane attivo ricevendo gossip e aggiornando lo stato.

2. PeerManager

ğŸ“„ File: peermanager.go

ğŸ‘¥ ResponsabilitÃ :

    Tiene traccia dei peer conosciuti (map[string]bool) e dei timestamp di ultimo heartbeat (LastSeen).

    Aggiorna chi Ã¨ "vivo", aggiunge nuovi peer, rimuove peer "morti".

ğŸ”§ Metodi chiave:

    Add(peer) â†’ aggiunge un peer alla mappa.

    Seen(peer) â†’ aggiorna il tempo di ultimo contatto.

    Remove(peer) â†’ rimuove il peer da tutte le mappe.

    List() â†’ restituisce la lista dei peer.

3. ServiceRegistry

ğŸ“„ File: serviceregistry.go

ğŸ› ï¸ ResponsabilitÃ :

    Tiene traccia di quali servizi (es. "payments", "auth") sono offerti da quali nodi.

    Ogni voce Ã¨: service â†’ {peer â†’ timestamp}.

ğŸ”§ Metodi chiave:

    AddLocal(id, svcCSV) â†’ registra i servizi offerti dal nodo stesso.

    Update(peer, services) â†’ aggiorna chi offre cosa da heartbeat ricevuti.

    RemoveProvider(peer) â†’ rimuove tutti i servizi offerti da un peer morto.

    Lookup(service) â†’ restituisce un provider casuale per un servizio.

4. DigestManager

ğŸ“„ File: digestmanager.go

ğŸ” ResponsabilitÃ :

    Calcola una firma SHA1 deterministica che rappresenta lo stato dei servizi conosciuti.

    Tiene traccia dell'ultimo digest inviato per ciascun peer (per evitare gossip inutili).

ğŸ”§ Metodi chiave:

    Compute(reg) â†’ calcola digest SHA1 sull'intero ServiceRegistry.

    Changed(peer, newDigest) â†’ true se il digest per quel peer Ã¨ diverso (trigger per heartbeat).

5. GossipManager

ğŸ“„ File: gossipmanager.go

ğŸ“£ ResponsabilitÃ :

    Ogni 3s manda heartbeat (con digest) ai peer.

    Solo se DigestManager.Changed() dice che qualcosa Ã¨ cambiato â†’ efficienza smart.

ğŸ”§ Metodi chiave:

    Start() â†’ loop periodico di invio heartbeat smart.

    sendUDP(data, peer) â†’ invio di un []byte UDP al peer.

6. FailureDetector

ğŸ“„ File: failuredetector.go

â˜ ï¸ ResponsabilitÃ :

    Ogni 1s, controlla se un peer Ã¨ silente da piÃ¹ di timeout (10s).

    Se sÃ¬, lo marca come morto â†’ rimosso da PeerManager e ServiceRegistry.

ğŸ”§ Metodo chiave:

    Start() â†’ avvia la goroutine periodica.

7. proto (protocollo messaggi)

ğŸ“„ File: proto.go (in pkg/proto)

ğŸ“¬ ResponsabilitÃ :

    Definisce il formato dei messaggi e la serializzazione/deserializzazione.

ğŸ“¦ Contiene:

    Envelope = messaggio con tipo, timestamp, mittente, payload.

    Heartbeat, Rumor = payload.

    Encode(...) / Decode(...) â†’ serializzazione JSON + timestamp automatico.

8. msgfactory.go

ğŸ“„ File: msgfactory.go

ğŸ­ ResponsabilitÃ :

    Costruisce messaggi di heartbeat giÃ  pronti per lâ€™invio.

ğŸ”§ Funzioni:

    MakeHeartbeatWithDigest(reg, digest) â†’ crea un heartbeat digest da inviare.

ğŸ” Flusso di esecuzione

    Ogni nodo avvia:

        UDP listener

        Gossip manager

        Failure detector

    Ogni 3 secondi:

        GossipManager calcola digest.

        Se Ã¨ cambiato, manda heartbeat a peer.

    All'arrivo di un heartbeat:

        Node decodifica messaggio.

        Aggiorna:

            PeerManager.Seen

            ServiceRegistry.Update

    Se un nodo non risponde:

        FailureDetector lo marca morto dopo 10s.

    Client (--lookup=...):

        Riceve gossip per 8s.

        Chiama Registry.Lookup(service).

âœï¸ Riepilogo concettuale
Componente	Scopo principale	PeriodicitÃ 
Node	Orchestratore principale	continua
PeerManager	Gestione peer e lastSeen	aggiornata da HB
ServiceRegistry	Mappa service â†’ peers	aggiornata da HB
DigestManager	SHA1 deterministico dello stato	ogni gossip
GossipManager	Invia heartbeat con digest	ogni 3s
FailureDetector	Rileva nodi morti	ogni 1s
proto	(De)serializzazione messaggi	costante



Documentazione: Architettura del Nodo nel Protocollo Gossip

Obiettivo Generale

Il progetto implementa un sistema distribuito in Go, in cui ogni nodo partecipa a un protocollo gossip per condividere informazioni sui servizi offerti e rilevare guasti.

Classi e Ruoli

1. Node

Rappresenta un nodo del sistema. Contiene:

PeerMgr: gestisce i peer conosciuti e i loro heartbeat.

Registry: mappa dei servizi offerti dai peer.

Digests: tiene traccia dellâ€™ultimo digest calcolato per ogni peer.

GossipM: logica di invio dei messaggi gossip.

FailureD: logica di rilevamento dei peer morti.

Il metodo Run avvia gossip, failure detector e il listener UDP. Se Ã¨ presente un lookup, attende alcuni heartbeat, effettua la lookup e termina.

2. PeerManager

Gestisce lo stato dei peer noti:

Peers: mappa dei peer attivi.

LastSeen: timestamp dellâ€™ultimo heartbeat ricevuto da ciascun peer.

Metodi principali:

Add(): registra un nuovo peer.

Seen(): aggiorna il timestamp.

Remove(): elimina peer scaduti.

List(): restituisce tutti i peer attivi.

3. ServiceRegistry

Tiene traccia di quali servizi sono offerti da quali peer.

Table: mappa servizio â†’ {peer â†’ lastSeen}.

Metodi:

AddLocal(): registra i servizi del nodo locale.

Update(): aggiorna i servizi conosciuti dai peer.

RemoveProvider(): rimuove tutti i servizi di un peer morto.

Lookup(): restituisce un provider a caso per un dato servizio.

4. DigestManager

Serve a evitare di inviare heartbeat inutili:

Compute(): calcola uno SHA1 deterministico dei servizi noti.

Changed(peer, digest): ritorna true se il digest Ã¨ cambiato rispetto allâ€™ultimo inviato a quel peer.

5. GossipManager

Si occupa dellâ€™invio periodico degli heartbeat:

Ogni 3 secondi, calcola il digest corrente.

Per ogni peer, se il digest Ã¨ cambiato rispetto allâ€™ultimo inviato, invia un heartbeat.

6. FailureDetector

Controlla ogni secondo se qualche peer non ha piÃ¹ inviato heartbeat da troppo tempo (timeout di default: 10s). Se un peer Ã¨ scaduto:

Viene rimosso da PeerMgr e da Registry.

Viene loggato come DEAD.

7. msgfactory.go

Contiene metodi di utilitÃ  per costruire heartbeat con digest:

MakeHeartbeatWithDigest(reg, digest): costruisce un proto.Heartbeat con digest e lo incapsula in un proto.Envelope.

8. proto.go

Contiene:

MsgType, Envelope, Heartbeat, Rumor: strutture base per serializzare messaggi.

Encode() e Decode(): serializzazione/deserializzazione generiche.

DecodeHeartbeat() e DecodeRumor() per parsing sicuro dei payload.

Conclusione

Lâ€™architettura Ã¨ modulare e ben separata:

Ogni componente ha una singola responsabilitÃ .

I peer comunicano via UDP, inviando heartbeat.

I servizi convergono tramite gossip e il client puÃ² eseguire una lookup di un servizio qualsiasi, anche dopo join dinamico.

Siamo ora pronti a estendere il protocollo con rumor mongering e fan-out configurabile!

